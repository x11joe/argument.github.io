<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Enhanced Argument Tree Visualizer – Shapes & Gravity</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      z-index: 10;
    }
    select, button {
      margin-right: 5px;
      font-size: 14px;
    }
    /* Styling for interactive buttons */
    .button-circle {
      stroke: darkgreen;
      stroke-width: 1px;
      fill: lightgreen;
      cursor: pointer;
    }
    .delete-circle {
      stroke: darkred;
      stroke-width: 1px;
      fill: salmon;
      cursor: pointer;
    }
    .collapse-circle {
      stroke: darkblue;
      stroke-width: 1px;
      fill: lightblue;
      cursor: pointer;
    }
    line.link {
      stroke: #ccc;
      stroke-width: 1.5px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <select id="argumentSelect"></select>
    <button id="newArgument">New Argument Tree</button>
  </div>
  <svg id="canvas" width="100%" height="100%"></svg>

  <!-- D3.js library -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    /***********************
     * Global Variables & Default Tree
     ***********************/
    let argumentTrees = {};
    let currentTreeName = "";
    let currentTree = {};

    // Default Gun Control Debate tree – same structure as before.
    const defaultGunControlTree = {
      claim: "Gun control is essential for reducing violent crime.",
      data: [
        {
          text: "Studies in Australia show a significant drop in gun violence after strict gun control measures.",
          counter: {
            claim: "However, Australia's societal context differs greatly from that of the US, making comparisons unreliable.",
            data: [
              {
                text: "Cultural, economic, and legal differences make the Australian model not directly applicable.",
                counter: {
                  claim: "Yet, many of these factors exist in the US too, meaning the argument still holds merit.",
                  data: [
                    { text: "Further analysis shows some similarities between the countries.", counter: null }
                  ],
                  warrants: []
                }
              }
            ],
            warrants: []
          }
        },
        {
          text: "Data from the US indicates that states with stricter gun laws experience fewer gun-related incidents.",
          counter: null
        }
      ],
      warrants: [
        {
          text: "Restricting access to firearms logically reduces the opportunity for violent acts.",
          counter: {
            claim: "Opponents argue that criminals do not adhere to laws, thus restrictions only affect law-abiding citizens.",
            data: [
              {
                text: "In many cases, the illegal arms trade supplies criminals regardless of restrictions.",
                counter: {
                  claim: "But the illegal arms trade thrives on other factors like corruption and organized crime, not merely the availability of guns.",
                  data: [
                    { text: "Reports indicate that organized crime networks have multiple supply channels.", counter: null }
                  ],
                  warrants: [
                    { text: "Thus, focusing solely on gun control might not be sufficient to curb crime.", counter: null }
                  ]
                }
              }
            ],
            warrants: []
          }
        },
        {
          text: "Effective regulation can ensure that only responsible individuals have access to firearms.",
          counter: null
        }
      ]
    };

    /***********************
     * Color Palette & Persistent Color Assignment
     ***********************/
    // A preset palette of pastel colors chosen to be maximally contrasting.
    const palette = [
      "hsl(0, 70%, 85%)",
      "hsl(180, 70%, 85%)",
      "hsl(90, 70%, 85%)",
      "hsl(270, 70%, 85%)",
      "hsl(45, 70%, 85%)",
      "hsl(225, 70%, 85%)",
      "hsl(135, 70%, 85%)",
      "hsl(315, 70%, 85%)"
    ];
    let nextColorIndex = 0;
    // Get a color from the palette in order.
    function getNextColor() {
      const color = palette[nextColorIndex];
      nextColorIndex = (nextColorIndex + 1) % palette.length;
      return color;
    }

    /***********************
     * Local Storage Helpers
     ***********************/
    function loadTrees() {
      const saved = localStorage.getItem('argumentTrees');
      if (saved) {
        argumentTrees = JSON.parse(saved);
      } else {
        argumentTrees = { "Gun Control Debate": defaultGunControlTree };
        updateLocalStorage();
      }
      currentTreeName = Object.keys(argumentTrees)[0];
      currentTree = argumentTrees[currentTreeName];
    }
    function updateLocalStorage() {
      localStorage.setItem('argumentTrees', JSON.stringify(argumentTrees));
    }
    function populateDropdown() {
      const select = document.getElementById('argumentSelect');
      select.innerHTML = "";
      for (let name in argumentTrees) {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        if (name === currentTreeName) option.selected = true;
        select.appendChild(option);
      }
      select.onchange = function() {
        currentTreeName = this.value;
        currentTree = argumentTrees[currentTreeName];
        updateVisualization();
      };
    }
    document.getElementById('newArgument').onclick = function() {
      const name = prompt("Enter a name for the new argument tree:");
      if (name) {
        argumentTrees[name] = { claim: "New Argument Claim", data: [], warrants: [] };
        currentTreeName = name;
        currentTree = argumentTrees[name];
        populateDropdown();
        updateVisualization();
        updateLocalStorage();
      }
    };

    /***********************
     * Hierarchy Conversion with Persistent Colors
     ***********************/
    // Converts an argument node into a hierarchical structure for D3.
    // For claim nodes, if no color is already assigned, assign one and store it.
    function convertArgumentNode(argNode, path) {
      if (!argNode.color) {
        argNode.color = getNextColor();
      }
      const newNode = {
        name: "Claim: " + argNode.claim,
        type: "claim",
        originalPath: path.concat(["claim"]),
        raw: argNode,
        bgColor: argNode.color
      };
      newNode.children = [];
      if (!argNode.collapsed) {
        argNode.data.forEach((d, i) => {
          let child = {
            name: "Data: " + d.text,
            type: "data",
            originalPath: path.concat(["data", i]),
            raw: d,
            bgColor: argNode.color  // Inherit parent's color
          };
          if (d.counter) {
            child.children = [convertArgumentNode(d.counter, path.concat(["data", i, "counter"]))];
          }
          newNode.children.push(child);
        });
        argNode.warrants.forEach((w, i) => {
          let child = {
            name: "Warrant: " + w.text,
            type: "warrant",
            originalPath: path.concat(["warrants", i]),
            raw: w,
            bgColor: argNode.color  // Inherit parent's color
          };
          if (w.counter) {
            child.children = [convertArgumentNode(w.counter, path.concat(["warrants", i, "counter"]))];
          }
          newNode.children.push(child);
        });
      }
      return newNode;
    }

    /***********************
     * Data Update Functions
     ***********************/
    function getObjectAtPath(obj, path) {
      for (let i = 0; i < path.length; i++) {
        obj = obj[path[i]];
      }
      return obj;
    }
    function updateArgumentText(path, newText) {
      let parent = getObjectAtPath(currentTree, path.slice(0, -1));
      let last = path[path.length - 1];
      if (last === "claim") {
        parent[last] = newText;
      } else {
        parent[last].text = newText;
      }
      updateLocalStorage();
    }
    function deleteArgumentNode(path) {
      let parentPath = path.slice(0, path.length - 1);
      let last = path[path.length - 1];
      let parent = getObjectAtPath(currentTree, parentPath);
      if (Array.isArray(parent)) {
        parent.splice(last, 1);
      } else if (last === "counter") {
        parent[last] = null;
      }
      updateLocalStorage();
    }
    function addCounterToNode(path) {
      let node = getObjectAtPath(currentTree, path);
      if (!node.counter) {
        node.counter = { claim: "New Counter Claim", data: [], warrants: [] };
      }
      updateLocalStorage();
    }

    /***********************
     * D3 Visualization with Force Simulation & Gravity
     ***********************/
    const svg = d3.select("#canvas");
    let width = window.innerWidth,
        height = window.innerHeight;
    svg.attr("width", width).attr("height", height);

    svg.call(d3.zoom().scaleExtent([0.1, 3]).on("zoom", event => {
      gContainer.attr("transform", event.transform);
    }));
    const gContainer = svg.append("g");

    // Helper: Wrap text inside a given width.
    function wrap(text, width) {
      text.each(function() {
        var textEl = d3.select(this),
            words = textEl.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineNumber = 0,
            lineHeight = 1.1, // ems
            x = textEl.attr("x"),
            y = textEl.attr("y"),
            dy = 0,
            tspan = textEl.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");
        while (word = words.pop()) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > width) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = textEl.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
          }
        }
      });
    }

    // Main update function using a force simulation.
    function updateVisualization() {
      gContainer.selectAll("*").remove();

      const rootData = convertArgumentNode(currentTree, []);
      const root = d3.hierarchy(rootData);
      const nodes = root.descendants();
      const links = root.links();

      // For each node, measure its label and compute dimensions.
      nodes.forEach(d => {
        let label = d.data.name.split(": ")[1];
        const fontSize = 12;
        const maxWidth = 200; // Maximum width before wrapping.
        // Create a temporary text element to measure size.
        let tempText = svg.append("text")
                          .attr("font-size", fontSize)
                          .attr("font-family", "sans-serif")
                          .text(label);
        let bbox = tempText.node().getBBox();
        tempText.remove();
        let lines = Math.ceil(bbox.width / maxWidth);
        let nodeWidth = Math.min(bbox.width, maxWidth) + 20;
        let nodeHeight = (lines * 16) + 20;
        d.nodeWidth = nodeWidth;
        d.nodeHeight = nodeHeight;
        d.radius = Math.sqrt((nodeWidth/2) ** 2 + (nodeHeight/2) ** 2);
      });

      // Set up a force simulation with a gravity-like force pulling nodes downward by depth.
      const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).distance(150).strength(1))
        .force("collide", d3.forceCollide().radius(d => d.radius + 10).iterations(2))
        .force("charge", d3.forceManyBody().strength(-200))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("y", d3.forceY(d => d.depth * 150).strength(0.8))
        .on("tick", ticked);

      // Draw links.
      const linkElements = gContainer.selectAll("line.link")
        .data(links)
        .enter()
        .append("line")
        .attr("class", "link");

      // Draw nodes.
      const nodeGroups = gContainer.selectAll("g.node")
        .data(nodes)
        .enter()
        .append("g")
        .attr("class", "node")
        .call(d3.drag()
          .on("start", dragStarted)
          .on("drag", dragged)
          .on("end", dragEnded)
        );

      // Append shapes conditionally based on node type.
      // For claim nodes: ellipse.
      nodeGroups.filter(d => d.data.type === "claim")
        .append("ellipse")
        .attr("cx", d => d.nodeWidth/2)
        .attr("cy", d => d.nodeHeight/2)
        .attr("rx", d => d.nodeWidth/2)
        .attr("ry", d => d.nodeHeight/2)
        .attr("fill", d => d.data.bgColor)
        .on("dblclick", (event, d) => {
          let currentText = d.data.name.split(": ")[1];
          let newText = prompt("Edit text:", currentText);
          if (newText !== null) {
            updateArgumentText(d.data.originalPath, newText);
            updateVisualization();
          }
        });

      // For data nodes: rectangle.
      nodeGroups.filter(d => d.data.type === "data")
        .append("rect")
        .attr("width", d => d.nodeWidth)
        .attr("height", d => d.nodeHeight)
        .attr("fill", d => d.data.bgColor)
        .on("dblclick", (event, d) => {
          let currentText = d.data.name.split(": ")[1];
          let newText = prompt("Edit text:", currentText);
          if (newText !== null) {
            updateArgumentText(d.data.originalPath, newText);
            updateVisualization();
          }
        });

      // For warrant nodes: triangle (polygon).
      nodeGroups.filter(d => d.data.type === "warrant")
        .append("polygon")
        .attr("points", d => {
          // Points: bottom left, top center, bottom right.
          return `0,${d.nodeHeight} ${d.nodeWidth/2},0 ${d.nodeWidth},${d.nodeHeight}`;
        })
        .attr("fill", d => d.data.bgColor)
        .on("dblclick", (event, d) => {
          let currentText = d.data.name.split(": ")[1];
          let newText = prompt("Edit text:", currentText);
          if (newText !== null) {
            updateArgumentText(d.data.originalPath, newText);
            updateVisualization();
          }
        });

      // Append text for all nodes, centered.
      nodeGroups.append("text")
        .attr("x", d => d.nodeWidth/2)
        .attr("y", d => d.nodeHeight/2)
        .attr("dy", "0.35em")
        .attr("text-anchor", "middle")
        .attr("font-size", 12)
        .attr("font-family", "sans-serif")
        .text(d => d.data.name.split(": ")[1])
        .each(function(d) {
          wrap(d3.select(this), d.nodeWidth - 20);
        });

      /***********************
       * Interactive Buttons
       ***********************/
      // For data/warrant nodes without a counter, add an "Add Counter" button.
      nodeGroups.filter(d => (d.data.type === "data" || d.data.type === "warrant") && !d.data.raw.counter)
        .append("circle")
        .attr("class", "button-circle")
        .attr("cx", d => d.nodeWidth - 10)
        .attr("cy", d => d.nodeHeight - 10)
        .attr("r", 8)
        .on("click", (event, d) => {
          event.stopPropagation();
          addCounterToNode(d.data.originalPath);
          updateVisualization();
        });
      nodeGroups.filter(d => (d.data.type === "data" || d.data.type === "warrant") && !d.data.raw.counter)
        .append("text")
        .attr("x", d => d.nodeWidth - 10)
        .attr("y", d => d.nodeHeight - 6)
        .attr("text-anchor", "middle")
        .attr("font-size", "10px")
        .text("+")
        .on("click", (event, d) => {
          event.stopPropagation();
          addCounterToNode(d.data.originalPath);
          updateVisualization();
        });

      // For claim nodes, add "Add Data" and "Add Warrant" buttons.
      nodeGroups.filter(d => d.data.type === "claim")
        .each(function(d) {
          const group = d3.select(this);
          // "Add Data" button.
          group.append("circle")
            .attr("class", "button-circle")
            .attr("cx", d.nodeWidth + 10)
            .attr("cy", d.nodeHeight/2 - 10)
            .attr("r", 8)
            .on("click", (event, d) => {
              event.stopPropagation();
              const newText = prompt("New Data text:");
              if (newText) {
                d.data.raw.data.push({ text: newText, counter: null });
                updateLocalStorage();
                updateVisualization();
              }
            });
          group.append("text")
            .attr("x", d.nodeWidth + 10)
            .attr("y", d.nodeHeight/2 - 6)
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .text("D")
            .on("click", (event, d) => {
              event.stopPropagation();
              const newText = prompt("New Data text:");
              if (newText) {
                d.data.raw.data.push({ text: newText, counter: null });
                updateLocalStorage();
                updateVisualization();
              }
            });
          // "Add Warrant" button.
          group.append("circle")
            .attr("class", "button-circle")
            .attr("cx", d.nodeWidth + 30)
            .attr("cy", d.nodeHeight/2 - 10)
            .attr("r", 8)
            .on("click", (event, d) => {
              event.stopPropagation();
              const newText = prompt("New Warrant text:");
              if (newText) {
                d.data.raw.warrants.push({ text: newText, counter: null });
                updateLocalStorage();
                updateVisualization();
              }
            });
          group.append("text")
            .attr("x", d.nodeWidth + 30)
            .attr("y", d.nodeHeight/2 - 6)
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .text("W")
            .on("click", (event, d) => {
              event.stopPropagation();
              const newText = prompt("New Warrant text:");
              if (newText) {
                d.data.raw.warrants.push({ text: newText, counter: null });
                updateLocalStorage();
                updateVisualization();
              }
            });
        });

      // For claim nodes with children, add a collapse/expand toggle.
      nodeGroups.filter(d => d.data.type === "claim" && (d.data.raw.data.length > 0 || d.data.raw.warrants.length > 0))
        .append("circle")
        .attr("class", "collapse-circle")
        .attr("cx", -10)
        .attr("cy", 10)
        .attr("r", 8)
        .on("click", (event, d) => {
          event.stopPropagation();
          d.data.raw.collapsed = !d.data.raw.collapsed;
          updateVisualization();
        });
      nodeGroups.filter(d => d.data.type === "claim" && (d.data.raw.data.length > 0 || d.data.raw.warrants.length > 0))
        .append("text")
        .attr("x", -10)
        .attr("y", 14)
        .attr("text-anchor", "middle")
        .attr("font-size", "10px")
        .text(d => d.data.raw.collapsed ? "+" : "-")
        .on("click", (event, d) => {
          event.stopPropagation();
          d.data.raw.collapsed = !d.data.raw.collapsed;
          updateVisualization();
        });

      // Add a delete button for non-root nodes.
      nodeGroups.filter(d => d.depth > 0)
        .append("circle")
        .attr("class", "delete-circle")
        .attr("cx", 10)
        .attr("cy", 10)
        .attr("r", 8)
        .on("click", (event, d) => {
          event.stopPropagation();
          if (confirm("Delete this node?")) {
            deleteArgumentNode(d.data.originalPath);
            updateVisualization();
          }
        });
      nodeGroups.filter(d => d.depth > 0)
        .append("text")
        .attr("x", 10)
        .attr("y", 14)
        .attr("text-anchor", "middle")
        .attr("font-size", "10px")
        .text("×")
        .on("click", (event, d) => {
          event.stopPropagation();
          if (confirm("Delete this node?")) {
            deleteArgumentNode(d.data.originalPath);
            updateVisualization();
          }
        });

      function ticked() {
        linkElements
          .attr("x1", d => d.source.x + d.source.nodeWidth/2)
          .attr("y1", d => d.source.y + d.source.nodeHeight/2)
          .attr("x2", d => d.target.x + d.target.nodeWidth/2)
          .attr("y2", d => d.target.y + d.target.nodeHeight/2);
        nodeGroups.attr("transform", d => "translate(" + d.x + "," + d.y + ")");
      }
      function dragStarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }
      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }
      function dragEnded(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }
    }

    window.addEventListener("resize", function() {
      width = window.innerWidth;
      height = window.innerHeight;
      svg.attr("width", width).attr("height", height);
      updateVisualization();
    });

    document.addEventListener("DOMContentLoaded", function() {
      loadTrees();
      populateDropdown();
      updateVisualization();
    });
  </script>
</body>
</html>
