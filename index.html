<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Argument Tree Visualizer</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      overflow: hidden;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      z-index: 10;
    }
    select, button {
      margin-right: 5px;
      font-size: 14px;
    }
    .node rect {
      fill: #fff;
      stroke: steelblue;
      stroke-width: 1.5px;
      rx: 5;
      ry: 5;
    }
    .node text {
      pointer-events: none;
      font-size: 12px;
    }
    .button-circle {
      fill: lightgreen;
      stroke: darkgreen;
      stroke-width: 1px;
      cursor: pointer;
    }
    .delete-circle {
      fill: salmon;
      stroke: darkred;
      stroke-width: 1px;
      cursor: pointer;
    }
    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 1.5px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <select id="argumentSelect"></select>
    <button id="newArgument">New Argument Tree</button>
  </div>
  <svg width="1200" height="800"></svg>

  <!-- D3.js library -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    /***********************
     * Global Variables
     ***********************/
    let argumentTrees = {};
    let currentTreeName = "";
    let currentTree = {};

    // Default Gun Control Debate tree – note the structure:
    // each argument node has a "claim" (or for data/warrant items, a "text") plus arrays "data" and "warrants".
    const defaultGunControlTree = {
      claim: "Gun control is essential for reducing violent crime.",
      data: [
        {
          text: "Studies in Australia show a significant drop in gun violence after strict gun control measures.",
          counter: {
            claim: "However, Australia's societal context differs greatly from that of the US, making comparisons unreliable.",
            data: [
              {
                text: "Cultural, economic, and legal differences make the Australian model not directly applicable.",
                counter: {
                  claim: "Yet, many of these factors exist in the US too, meaning the argument still holds merit.",
                  data: [
                    { text: "Further analysis shows some similarities between the countries.", counter: null }
                  ],
                  warrants: []
                }
              }
            ],
            warrants: []
          }
        },
        {
          text: "Data from the US indicates that states with stricter gun laws experience fewer gun-related incidents.",
          counter: null
        }
      ],
      warrants: [
        {
          text: "Restricting access to firearms logically reduces the opportunity for violent acts.",
          counter: {
            claim: "Opponents argue that criminals do not adhere to laws, thus restrictions only affect law-abiding citizens.",
            data: [
              {
                text: "In many cases, the illegal arms trade supplies criminals regardless of restrictions.",
                counter: {
                  claim: "But the illegal arms trade thrives on other factors like corruption and organized crime, not merely the availability of guns.",
                  data: [
                    { text: "Reports indicate that organized crime networks have multiple supply channels.", counter: null }
                  ],
                  warrants: [
                    { text: "Thus, focusing solely on gun control might not be sufficient to curb crime.", counter: null }
                  ]
                }
              }
            ],
            warrants: []
          }
        },
        {
          text: "Effective regulation can ensure that only responsible individuals have access to firearms.",
          counter: null
        }
      ]
    };

    /***********************
     * Local Storage Helpers
     ***********************/
    function loadTrees() {
      const saved = localStorage.getItem('argumentTrees');
      if (saved) {
        argumentTrees = JSON.parse(saved);
      } else {
        argumentTrees = { "Gun Control Debate": defaultGunControlTree };
        updateLocalStorage();
      }
      currentTreeName = Object.keys(argumentTrees)[0];
      currentTree = argumentTrees[currentTreeName];
    }
    function updateLocalStorage() {
      localStorage.setItem('argumentTrees', JSON.stringify(argumentTrees));
    }
    function populateDropdown() {
      const select = document.getElementById('argumentSelect');
      select.innerHTML = "";
      for (let name in argumentTrees) {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        if (name === currentTreeName) option.selected = true;
        select.appendChild(option);
      }
      select.addEventListener('change', function() {
        currentTreeName = this.value;
        currentTree = argumentTrees[currentTreeName];
        updateVisualization();
      });
    }
    document.getElementById('newArgument').addEventListener('click', function(){
      const name = prompt("Enter a name for the new argument tree:");
      if (name) {
        argumentTrees[name] = { claim: "New Argument Claim", data: [], warrants: [] };
        currentTreeName = name;
        currentTree = argumentTrees[name];
        populateDropdown();
        updateVisualization();
        updateLocalStorage();
      }
    });

    /***********************
     * Conversion: Argument to Hierarchy for D3
     ***********************/
    // We convert our custom argument structure into a hierarchical object.
    // Each node gets an "originalPath" so we can later update the underlying tree.
    function convertArgumentNode(argNode, path) {
      // For a claim node (either root or counter branch)
      let newNode = {
        name: "Claim: " + argNode.claim,
        type: "claim",
        originalPath: path.concat(["claim"]),
        raw: argNode
      };
      newNode.children = [];
      // Data items – original path for a data node is: [ "data", index ]
      argNode.data.forEach((d, i) => {
        let child = {
          name: "Data: " + d.text,
          type: "data",
          originalPath: path.concat(["data", i]),
          raw: d
        };
        if(d.counter) {
          child.children = [convertArgumentNode(d.counter, path.concat(["data", i, "counter"]))];
        }
        newNode.children.push(child);
      });
      // Warrant items – original path for a warrant node is: [ "warrants", index ]
      argNode.warrants.forEach((w, i) => {
        let child = {
          name: "Warrant: " + w.text,
          type: "warrant",
          originalPath: path.concat(["warrants", i]),
          raw: w
        };
        if(w.counter) {
          child.children = [convertArgumentNode(w.counter, path.concat(["warrants", i, "counter"]))];
        }
        newNode.children.push(child);
      });
      return newNode;
    }

    /***********************
     * Update Underlying Data
     ***********************/
    // Helper to traverse the currentTree structure using a path array.
    function getObjectAtPath(obj, path) {
      for (let i = 0; i < path.length; i++) {
        obj = obj[path[i]];
      }
      return obj;
    }
    // Update the text for a node. For claim nodes, update the "claim" property;
    // for data/warrant nodes, update the "text" property.
    function updateArgumentText(path, newText) {
      let parent = getObjectAtPath(currentTree, path.slice(0, -1));
      let last = path[path.length - 1];
      if (last === "claim") {
        parent[last] = newText;
      } else {
        parent[last].text = newText;
      }
      updateLocalStorage();
    }
    // Delete a node given its originalPath.
    // If the node is in an array (data or warrants), remove it;
    // if it's a counter branch, set it to null.
    function deleteArgumentNode(path) {
      let parentPath = path.slice(0, path.length - 1);
      let last = path[path.length - 1];
      let parent = getObjectAtPath(currentTree, parentPath);
      if (Array.isArray(parent)) {
        parent.splice(last, 1);
      } else if (last === "counter") {
        parent[last] = null;
      }
      updateLocalStorage();
    }
    // Add a counter branch to a node (only applicable for data or warrant nodes)
    function addCounterToNode(path) {
      let node = getObjectAtPath(currentTree, path);
      if (!node.counter) {
        node.counter = { claim: "New Counter Claim", data: [], warrants: [] };
      }
      updateLocalStorage();
    }

    /***********************
     * D3 Visualization Setup
     ***********************/
    const svg = d3.select("svg");
    const width = +svg.attr("width");
    const height = +svg.attr("height");

    // Create a container group for pan & zoom.
    const gContainer = svg.append("g");

    // Setup zoom behavior.
    svg.call(d3.zoom()
      .scaleExtent([0.1, 3])
      .on("zoom", (event) => {
        gContainer.attr("transform", event.transform);
      }));

    // Tree layout configuration.
    const treeLayout = d3.tree().size([width - 100, height - 100]);

    /***********************
     * Update Visualization
     ***********************/
    function updateVisualization() {
      // Convert our current tree to hierarchical data.
      const rootData = convertArgumentNode(currentTree, []);
      const root = d3.hierarchy(rootData);
      treeLayout(root);

      // Clear any existing nodes and links.
      gContainer.selectAll(".link").remove();
      gContainer.selectAll(".node").remove();

      // Draw links.
      const link = gContainer.selectAll(".link")
        .data(root.links())
        .enter()
        .append("path")
        .attr("class", "link")
        .attr("d", d3.linkVertical()
                      .x(d => d.x + 50)
                      .y(d => d.y + 20));

      // Draw nodes.
      const node = gContainer.selectAll(".node")
        .data(root.descendants())
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", d => "translate(" + d.x + "," + d.y + ")")
        .call(d3.drag()
          .on("drag", (event, d) => {
            d.x += event.dx;
            d.y += event.dy;
            d3.select(event.sourceEvent.target.parentNode)
              .attr("transform", "translate(" + d.x + "," + d.y + ")");
            // Update links connected to this node.
            gContainer.selectAll(".link")
              .attr("d", d3.linkVertical()
                          .x(d => d.x + 50)
                          .y(d => d.y + 20));
          }));

      // Node rectangle
      node.append("rect")
        .attr("width", 100)
        .attr("height", 40)
        .attr("x", 0)
        .attr("y", 0)
        .on("dblclick", (event, d) => {
          // On double-click, prompt to edit the node's text.
          let newText = prompt("Edit text:", (d.data.name.split(": ")[1]));
          if (newText !== null) {
            updateArgumentText(d.data.originalPath, newText);
            updateVisualization();
          }
        });

      // Node label
      node.append("text")
        .attr("x", 50)
        .attr("y", 25)
        .attr("text-anchor", "middle")
        .attr("pointer-events", "none")
        .text(d => d.data.name);

      // Add "Add Counter" button for data or warrant nodes that do not yet have a counter.
      node.filter(d => (d.data.type === "data" || d.data.type === "warrant") && !d.data.raw.counter)
          .append("circle")
          .attr("class", "button-circle")
          .attr("cx", 90)
          .attr("cy", 35)
          .attr("r", 8)
          .on("click", (event, d) => {
            // Prevent zoom from triggering.
            event.stopPropagation();
            addCounterToNode(d.data.originalPath);
            updateVisualization();
          });
      node.filter(d => (d.data.type === "data" || d.data.type === "warrant") && !d.data.raw.counter)
          .append("text")
          .attr("x", 90)
          .attr("y", 39)
          .attr("text-anchor", "middle")
          .attr("font-size", "10px")
          .attr("pointer-events", "none")
          .text("+");

      // Add "delete" button for nodes that are not the root.
      node.filter(d => d.depth > 0)
          .append("circle")
          .attr("class", "delete-circle")
          .attr("cx", 10)
          .attr("cy", 10)
          .attr("r", 8)
          .on("click", (event, d) => {
            event.stopPropagation();
            if (confirm("Delete this node?")) {
              deleteArgumentNode(d.data.originalPath);
              updateVisualization();
            }
          });
      node.filter(d => d.depth > 0)
          .append("text")
          .attr("x", 10)
          .attr("y", 14)
          .attr("text-anchor", "middle")
          .attr("font-size", "10px")
          .attr("pointer-events", "none")
          .text("×");
    }

    /***********************
     * Initialize Application
     ***********************/
    document.addEventListener('DOMContentLoaded', function() {
      loadTrees();
      populateDropdown();
      updateVisualization();
    });
  </script>
</body>
</html>
