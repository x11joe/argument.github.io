<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Argument Tree Visualizer – Tree Layout</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      z-index: 10;
    }
    select, button {
      margin-right: 5px;
      font-size: 14px;
    }
    /* Button styling for interactive elements */
    .button-circle {
      stroke: darkgreen;
      stroke-width: 1px;
      fill: lightgreen;
      cursor: pointer;
    }
    .delete-circle {
      stroke: darkred;
      stroke-width: 1px;
      fill: salmon;
      cursor: pointer;
    }
    .collapse-circle {
      stroke: darkblue;
      stroke-width: 1px;
      fill: lightblue;
      cursor: pointer;
    }
    /* Link styling */
    path.link {
      fill: none;
      stroke: #ccc;
      stroke-width: 1.5px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <select id="argumentSelect"></select>
    <button id="newArgument">New Argument Tree</button>
    <button id="clearAll">Clear All</button>
    <button id="loadExternal">Load External Argument</button>
  </div>
  <svg id="canvas" width="100%" height="100%"></svg>

  <!-- D3.js library -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    /***********************
     * Global Variables & Expanded Default Tree
     ***********************/
    let argumentTrees = {};
    let currentTreeName = "";
    let currentTree = {};

    // Expanded default tree (this will only be used if you create a new tree)
    const defaultTree = {
      claim: "New Argument Claim",
      data: [],
      warrants: []
    };

    /***********************
     * Color Palette & Persistent Color Assignment
     ***********************/
    // A preset palette of pastel colors chosen for contrast.
    const palette = [
      "hsl(0, 70%, 85%)",
      "hsl(180, 70%, 85%)",
      "hsl(90, 70%, 85%)",
      "hsl(270, 70%, 85%)",
      "hsl(45, 70%, 85%)",
      "hsl(225, 70%, 85%)",
      "hsl(135, 70%, 85%)",
      "hsl(315, 70%, 85%)"
    ];
    let nextColorIndex = 0;
    function getNextColor() {
      const color = palette[nextColorIndex];
      nextColorIndex = (nextColorIndex + 1) % palette.length;
      return color;
    }

    /***********************
     * Local Storage Helpers
     ***********************/
    function loadTrees() {
      const saved = localStorage.getItem('argumentTrees');
      if (saved) {
        argumentTrees = JSON.parse(saved);
      } else {
        // Start with an empty set (external files will populate these)
        argumentTrees = {};
        updateLocalStorage();
      }
      currentTreeName = Object.keys(argumentTrees)[0] || "";
      currentTree = currentTreeName ? argumentTrees[currentTreeName] : null;
    }
    function updateLocalStorage() {
      localStorage.setItem('argumentTrees', JSON.stringify(argumentTrees));
    }
    function populateDropdown() {
      const select = document.getElementById('argumentSelect');
      select.innerHTML = "";
      for (let name in argumentTrees) {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        if (name === currentTreeName) option.selected = true;
        select.appendChild(option);
      }
      select.onchange = function() {
        currentTreeName = this.value;
        currentTree = argumentTrees[currentTreeName];
        updateVisualization();
      };
    }
    document.getElementById('newArgument').onclick = function() {
      const name = prompt("Enter a name for the new argument tree:");
      if (name) {
        argumentTrees[name] = JSON.parse(JSON.stringify(defaultTree));
        currentTreeName = name;
        currentTree = argumentTrees[name];
        populateDropdown();
        updateVisualization();
        updateLocalStorage();
      }
    };
    document.getElementById('clearAll').onclick = function() {
      if (confirm("Are you sure you want to clear all arguments?")) {
        argumentTrees = {};
        currentTreeName = "";
        currentTree = null;
        updateLocalStorage();
        populateDropdown();
        updateVisualization();
      }
    };

    // New: Load External Argument – expects an external file index (arguments/index.json)
    document.getElementById('loadExternal').onclick = function() {
      d3.json('arguments/index.json')
        .then(function(indexData) {
          if (indexData && indexData.arguments && indexData.arguments.length > 0) {
            let options = indexData.arguments.map((f, i) => i + ": " + f).join("\n");
            let choice = prompt("Available argument files:\n" + options + "\nEnter the index number of the argument file to load:");
            let idx = parseInt(choice);
            if (!isNaN(idx) && idx >= 0 && idx < indexData.arguments.length) {
              let fileName = indexData.arguments[idx];
              d3.json('arguments/' + fileName)
                .then(function(data) {
                  argumentTrees[fileName] = data;
                  currentTreeName = fileName;
                  currentTree = data;
                  updateLocalStorage();
                  populateDropdown();
                  updateVisualization();
                })
                .catch(function(err) {
                  alert("Error loading file: " + fileName);
                });
            } else {
              alert("Invalid choice.");
            }
          } else {
            alert("No external argument files found.");
          }
        })
        .catch(function(err) {
          alert("Error scanning folder: " + err);
        });
    };

    /***********************
     * Hierarchy Conversion with Persistent Colors
     ***********************/
    // Converts our argument node into a hierarchical object for D3.
    // For claim nodes, if no color is already assigned, one is assigned and stored.
    function convertArgumentNode(argNode, path) {
      if (!argNode.color) {
        argNode.color = getNextColor();
      }
      const newNode = {
        name: "Claim: " + argNode.claim,
        type: "claim",
        originalPath: path.concat(["claim"]),
        raw: argNode,
        bgColor: argNode.color
      };
      newNode.children = [];
      if (!argNode.collapsed) {
        argNode.data.forEach((d, i) => {
          let child = {
            name: "Data: " + d.text,
            type: "data",
            originalPath: path.concat(["data", i]),
            raw: d,
            bgColor: argNode.color
          };
          if (d.counter) {
            child.children = [convertArgumentNode(d.counter, path.concat(["data", i, "counter"]))];
          }
          newNode.children.push(child);
        });
        argNode.warrants.forEach((w, i) => {
          let child = {
            name: "Warrant: " + w.text,
            type: "warrant",
            originalPath: path.concat(["warrants", i]),
            raw: w,
            bgColor: argNode.color
          };
          if (w.counter) {
            child.children = [convertArgumentNode(w.counter, path.concat(["warrants", i, "counter"]))];
          }
          newNode.children.push(child);
        });
      }
      return newNode;
    }

    /***********************
     * Data Update Functions
     ***********************/
    function getObjectAtPath(obj, path) {
      for (let i = 0; i < path.length; i++) {
        obj = obj[path[i]];
      }
      return obj;
    }
    function updateArgumentText(path, newText) {
      let parent = getObjectAtPath(currentTree, path.slice(0, -1));
      let last = path[path.length - 1];
      if (last === "claim") {
        parent[last] = newText;
      } else {
        parent[last].text = newText;
      }
      updateLocalStorage();
    }
    function deleteArgumentNode(path) {
      let parentPath = path.slice(0, path.length - 1);
      let last = path[path.length - 1];
      let parent = getObjectAtPath(currentTree, parentPath);
      if (Array.isArray(parent)) {
        parent.splice(last, 1);
      } else if (last === "counter") {
        parent[last] = null;
      }
      updateLocalStorage();
    }
    function addCounterToNode(path) {
      let node = getObjectAtPath(currentTree, path);
      if (!node.counter) {
        node.counter = { claim: "New Counter Claim", data: [], warrants: [] };
      }
      updateLocalStorage();
    }

    /***********************
     * D3 Tree Layout Visualization
     ***********************/
    const svg = d3.select("#canvas");
    let width = window.innerWidth,
        height = window.innerHeight;
    svg.attr("width", width).attr("height", height);

    // Set up pan/zoom.
    svg.call(d3.zoom().scaleExtent([0.1, 3]).on("zoom", event => {
      gContainer.attr("transform", event.transform);
    }));
    const gContainer = svg.append("g");

    // Helper: Wrap text within a given width.
    function wrap(text, width) {
      text.each(function() {
        var textEl = d3.select(this),
            words = textEl.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineNumber = 0,
            lineHeight = 1.1, // ems
            x = textEl.attr("x"),
            y = textEl.attr("y"),
            dy = 0,
            tspan = textEl.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");
        while (word = words.pop()) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > width) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = textEl.append("tspan").attr("x", x).attr("y", y)
                    .attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
          }
        }
      });
    }

    function updateVisualization() {
      gContainer.selectAll("*").remove();
      if (!currentTree) return;
      
      // Convert our custom argument structure to a hierarchical object.
      const rootData = convertArgumentNode(currentTree, []);
      const root = d3.hierarchy(rootData);
      
      // Use d3.tree layout for a clear, hierarchical arrangement.
      const treeLayout = d3.tree()
        .size([width - 160, height - 100])
        .separation((a, b) => a.parent === b.parent ? 1 : 2);
      treeLayout(root);
      
      // For each node, measure the label to determine shape size.
      root.descendants().forEach(d => {
        let label = d.data.name.split(": ")[1];
        const fontSize = 12;
        const maxWidth = 200;
        // Temporary text measurement.
        let tempText = svg.append("text")
                          .attr("font-size", fontSize)
                          .attr("font-family", "sans-serif")
                          .text(label);
        let bbox = tempText.node().getBBox();
        tempText.remove();
        let lines = Math.ceil(bbox.width / maxWidth);
        let nodeWidth = Math.min(bbox.width, maxWidth) + 20;
        let nodeHeight = (lines * 16) + 20;
        d.nodeWidth = nodeWidth;
        d.nodeHeight = nodeHeight;
      });
      
      // Draw links using a vertical link generator.
      const linkGenerator = d3.linkVertical()
                              .x(d => d.x + d.nodeWidth/2)
                              .y(d => d.y + d.nodeHeight/2);
      gContainer.selectAll("path.link")
        .data(root.links())
        .enter()
        .append("path")
        .attr("class", "link")
        .attr("d", d => linkGenerator({
          source: { x: d.source.x, y: d.source.y, nodeWidth: d.source.nodeWidth, nodeHeight: d.source.nodeHeight },
          target: { x: d.target.x, y: d.target.y, nodeWidth: d.target.nodeWidth, nodeHeight: d.target.nodeHeight }
        }));
      
      // Draw nodes.
      const nodeGroups = gContainer.selectAll("g.node")
        .data(root.descendants())
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", d => "translate(" + d.x + "," + d.y + ")");
      
      // Append shapes based on type.
      // Claim nodes as ellipses.
      nodeGroups.filter(d => d.data.type === "claim")
        .append("ellipse")
        .attr("cx", d => d.nodeWidth/2)
        .attr("cy", d => d.nodeHeight/2)
        .attr("rx", d => d.nodeWidth/2)
        .attr("ry", d => d.nodeHeight/2)
        .attr("fill", d => d.data.bgColor)
        .on("dblclick", (event, d) => {
          let currentText = d.data.name.split(": ")[1];
          let newText = prompt("Edit text:", currentText);
          if(newText !== null) {
            updateArgumentText(d.data.originalPath, newText);
            updateVisualization();
          }
        });
      // Data nodes as rectangles.
      nodeGroups.filter(d => d.data.type === "data")
        .append("rect")
        .attr("width", d => d.nodeWidth)
        .attr("height", d => d.nodeHeight)
        .attr("fill", d => d.data.bgColor)
        .on("dblclick", (event, d) => {
          let currentText = d.data.name.split(": ")[1];
          let newText = prompt("Edit text:", currentText);
          if(newText !== null) {
            updateArgumentText(d.data.originalPath, newText);
            updateVisualization();
          }
        });
      // Warrant nodes as triangles.
      nodeGroups.filter(d => d.data.type === "warrant")
        .append("polygon")
        .attr("points", d => `0,${d.nodeHeight} ${d.nodeWidth/2},0 ${d.nodeWidth},${d.nodeHeight}`)
        .attr("fill", d => d.data.bgColor)
        .on("dblclick", (event, d) => {
          let currentText = d.data.name.split(": ")[1];
          let newText = prompt("Edit text:", currentText);
          if(newText !== null) {
            updateArgumentText(d.data.originalPath, newText);
            updateVisualization();
          }
        });
      
      // Append centered text.
      nodeGroups.append("text")
        .attr("x", d => d.nodeWidth/2)
        .attr("y", d => d.nodeHeight/2)
        .attr("dy", "0.35em")
        .attr("text-anchor", "middle")
        .attr("font-size", 12)
        .attr("font-family", "sans-serif")
        .text(d => d.data.name.split(": ")[1])
        .each(function(d) {
          wrap(d3.select(this), d.nodeWidth - 20);
        });
      
      /*********************** Interactive Buttons ***********************/
      // For data/warrant nodes without a counter, add an "Add Counter" button.
      nodeGroups.filter(d => (d.data.type==="data" || d.data.type==="warrant") && !d.data.raw.counter)
        .append("circle")
        .attr("class", "button-circle")
        .attr("cx", d => d.nodeWidth - 10)
        .attr("cy", d => d.nodeHeight - 10)
        .attr("r", 8)
        .on("click", (event, d) => {
          event.stopPropagation();
          addCounterToNode(d.data.originalPath);
          updateVisualization();
        });
      nodeGroups.filter(d => (d.data.type==="data" || d.data.type==="warrant") && !d.data.raw.counter)
        .append("text")
        .attr("x", d => d.nodeWidth - 10)
        .attr("y", d => d.nodeHeight - 6)
        .attr("text-anchor", "middle")
        .attr("font-size", "10px")
        .text("+")
        .on("click", (event, d) => {
          event.stopPropagation();
          addCounterToNode(d.data.originalPath);
          updateVisualization();
        });
      
      // For claim nodes, add "Add Data" and "Add Warrant" buttons.
      nodeGroups.filter(d => d.data.type==="claim")
        .each(function(d) {
          const group = d3.select(this);
          // "Add Data" button.
          group.append("circle")
            .attr("class", "button-circle")
            .attr("cx", d.nodeWidth + 10)
            .attr("cy", d.nodeHeight/2 - 10)
            .attr("r", 8)
            .on("click", (event, d) => {
              event.stopPropagation();
              const newText = prompt("New Data text:");
              if(newText) {
                d.data.raw.data.push({ text: newText, counter: null });
                updateLocalStorage();
                updateVisualization();
              }
            });
          group.append("text")
            .attr("x", d.nodeWidth + 10)
            .attr("y", d.nodeHeight/2 - 6)
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .text("D")
            .on("click", (event, d) => {
              event.stopPropagation();
              const newText = prompt("New Data text:");
              if(newText) {
                d.data.raw.data.push({ text: newText, counter: null });
                updateLocalStorage();
                updateVisualization();
              }
            });
          // "Add Warrant" button.
          group.append("circle")
            .attr("class", "button-circle")
            .attr("cx", d.nodeWidth + 30)
            .attr("cy", d.nodeHeight/2 - 10)
            .attr("r", 8)
            .on("click", (event, d) => {
              event.stopPropagation();
              const newText = prompt("New Warrant text:");
              if(newText) {
                d.data.raw.warrants.push({ text: newText, counter: null });
                updateLocalStorage();
                updateVisualization();
              }
            });
          group.append("text")
            .attr("x", d.nodeWidth + 30)
            .attr("y", d.nodeHeight/2 - 6)
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .text("W")
            .on("click", (event, d) => {
              event.stopPropagation();
              const newText = prompt("New Warrant text:");
              if(newText) {
                d.data.raw.warrants.push({ text: newText, counter: null });
                updateLocalStorage();
                updateVisualization();
              }
            });
        });
      
      // For claim nodes with children, add a collapse/expand toggle.
      nodeGroups.filter(d => d.data.type==="claim" && (d.data.raw.data.length>0 || d.data.raw.warrants.length>0))
        .append("circle")
        .attr("class", "collapse-circle")
        .attr("cx", -10)
        .attr("cy", 10)
        .attr("r", 8)
        .on("click", (event, d) => {
          event.stopPropagation();
          d.data.raw.collapsed = !d.data.raw.collapsed;
          updateVisualization();
        });
      nodeGroups.filter(d => d.data.type==="claim" && (d.data.raw.data.length>0 || d.data.raw.warrants.length>0))
        .append("text")
        .attr("x", -10)
        .attr("y", 14)
        .attr("text-anchor", "middle")
        .attr("font-size", "10px")
        .text(d => d.data.raw.collapsed ? "+" : "-")
        .on("click", (event, d) => {
          event.stopPropagation();
          d.data.raw.collapsed = !d.data.raw.collapsed;
          updateVisualization();
        });
      
      // Add a delete button for non-root nodes.
      nodeGroups.filter(d => d.depth > 0)
        .append("circle")
        .attr("class", "delete-circle")
        .attr("cx", 10)
        .attr("cy", 10)
        .attr("r", 8)
        .on("click", (event, d) => {
          event.stopPropagation();
          if(confirm("Delete this node?")){
            deleteArgumentNode(d.data.originalPath);
            updateVisualization();
          }
        });
      nodeGroups.filter(d => d.depth > 0)
        .append("text")
        .attr("x", 10)
        .attr("y", 14)
        .attr("text-anchor", "middle")
        .attr("font-size", "10px")
        .text("×")
        .on("click", (event, d) => {
          event.stopPropagation();
          if(confirm("Delete this node?")){
            deleteArgumentNode(d.data.originalPath);
            updateVisualization();
          }
        });
    }

    window.addEventListener("resize", function(){
      width = window.innerWidth;
      height = window.innerHeight;
      svg.attr("width", width).attr("height", height);
      updateVisualization();
    });

    document.addEventListener("DOMContentLoaded", function(){
      loadTrees();
      populateDropdown();
      updateVisualization();
    });
  </script>
</body>
</html>
